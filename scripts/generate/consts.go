package main

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
)

func generateConsts(d APIDescription) error {
	consts := strings.Builder{}
	consts.WriteString(`
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Regen by running 'go generate' in the repo root.

package gotgbot

`)

	updateConsts, err := generateUpdateTypeConsts(d)
	if err != nil {
		return fmt.Errorf("failed to generate consts for update types: %w", err)
	}
	consts.WriteString(updateConsts)

	consts.WriteString(generateParseModeConsts())

	chatActions, err := generateChatActionConsts(d)
	if err != nil {
		return fmt.Errorf("failed to generate consts for chat actions: %w", err)
	}
	consts.WriteString(chatActions)

	stickerTypeConsts, err := generateTypeConsts(d, "Sticker")
	if err != nil {
		return fmt.Errorf("failed to generate consts for sticker types: %w", err)
	}
	consts.WriteString(stickerTypeConsts)

	chatTypeConsts, err := generateTypeConsts(d, "Chat")
	if err != nil {
		return fmt.Errorf("failed to generate consts for chat types: %w", err)
	}
	consts.WriteString(chatTypeConsts)

	return writeGenToFile(consts, "gen_consts.go")
}

func generateUpdateTypeConsts(d APIDescription) (string, error) {
	updType, ok := d.Types["Update"]
	if !ok {
		return "", errors.New("missing 'Update' type data")
	}
	out := strings.Builder{}
	// First we generate the consts
	out.WriteString("\n// The consts listed below represent all the update types that can be requested from telegram.")
	out.WriteString("\nconst (")
	for _, f := range updType.Fields {
		if f.Required {
			// All the update types are optional, so skip required values.
			continue
		}
		out.WriteString(writeConst("UpdateType"+snakeToTitle(f.Name), f.Name))
	}
	out.WriteString(")\n")

	// Then we generate the helper for the update kind logic
	out.WriteString("\n// GetType is a helper method to easily identify the type of update that is being received.")
	out.WriteString("\nfunc (u Update) GetType() string {")
	out.WriteString("\nswitch {")
	for _, f := range updType.Fields {
		if f.Required {
			// All the update types are optional, so skip required values.
			continue
		}
		out.WriteString(fmt.Sprintf("\ncase u.%s != nil:", snakeToTitle(f.Name)))
		out.WriteString("\nreturn UpdateType" + snakeToTitle(f.Name) + "\n")

	}
	out.WriteString("\ndefault:")
	out.WriteString("\nreturn \"unknown\"")
	out.WriteString("\n}")
	out.WriteString("\n}")
	return out.String(), nil
}

func generateTypeConsts(d APIDescription, typeName string) (string, error) {
	updType, ok := d.Types[typeName]
	if !ok {
		return "", errors.New("missing '" + typeName + "' type data")
	}
	out := strings.Builder{}
	out.WriteString("\n// The consts listed below represent all the " + strings.ToLower(typeName) + " types that can be obtained from telegram.")
	out.WriteString("\nconst (")
	for _, f := range updType.Fields {
		if f.Name != "type" {
			// the field we want to look at is called "type", ignore all others.
			continue
		}
		types, err := extractQuotedValues(f.Description)
		if err != nil {
			return "", fmt.Errorf("failed to get quoted types: %w", err)
		}
		for _, t := range types {
			out.WriteString(writeConst(typeName+"Type"+snakeToTitle(t), t))
		}
	}
	out.WriteString(")\n\n")
	return out.String(), nil
}

func generateParseModeConsts() string {
	// Adding these manually because they're not part of the spec, and theyre not going to change much anyway.
	formattingTypes := []string{"HTML", "MarkdownV2", "Markdown", "None"}

	out := strings.Builder{}
	out.WriteString("\n// The consts listed below represent all the parse_mode options that can be sent to telegram.")
	out.WriteString("\nconst (")
	for _, t := range formattingTypes {
		constName := "ParseMode" + t
		if t == "None" {
			// no parsemode == empty string value.
			out.WriteString(writeConst(constName, ""))
			continue
		}
		out.WriteString(writeConst(constName, t))
	}
	out.WriteString(")\n\n")
	return out.String()
}

func generateChatActionConsts(d APIDescription) (string, error) {
	methodName := "sendChatAction"
	fieldName := "action"

	sendChatActionMethod, ok := d.Methods[methodName]
	if !ok {
		return "", errors.New("missing '" + methodName + "' method data")
	}

	var description string

	for _, field := range sendChatActionMethod.Fields {
		if field.Name == fieldName {
			description = field.Description

			break
		}
	}

	if description == "" {
		return "", errors.New("missing '" + fieldName + "' method field")
	}

	// Parse chat action from the description
	var chatActions []string

	re := regexp.MustCompile(`(?P<action>[a-z_]+) f?or`)
	results := re.FindAllStringSubmatch(description, -1)

	for _, result := range results {
		chatActions = append(chatActions, result[1])
	}

	out := strings.Builder{}
	out.WriteString("\n// The consts listed below represent all the chat action options that can be sent to telegram.")
	out.WriteString("\nconst (")

	for _, a := range chatActions {
		constName := "ChatAction" + snakeToTitle(a)
		out.WriteString(writeConst(constName, a))
	}

	out.WriteString(")\n\n")

	return out.String(), nil
}

func writeConst(name string, value string) string {
	return fmt.Sprintf("\n%s = \"%s\"", name, value)
}
